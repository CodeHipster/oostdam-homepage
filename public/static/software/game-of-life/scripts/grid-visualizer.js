// Generated by CoffeeScript 2.5.1
(function() {
  /*
  prerequists:  grid cannot be 0 sized.
          grid is rectangular.
  */
  define(['grid-tools', 'jquery', 'jq-canvas', 'grid'], function(gridTools, jquery, jqCanvas, grid) {
    var canvasRatio, cellSize, ctx, gridRatio, moduleName, visualizer;
    moduleName = "grid-visualizer";
    console.log(moduleName);
    visualizer = {
      cellSize: null,
      context: null,
      hoverOverCell: null,
      // calculate which tile(x,y) the pixel x,y refers to
      getCellFromPixels: function(x, y) {
        var tx, ty;
        tx = Math.floor(x / cellSize);
        ty = Math.floor(y / cellSize);
        return {
          x: tx,
          y: ty
        };
      },
      // render draws the grid on the canvas.
      //todo rename grid as it is not the grid object....
      render: function(grid) {
        var cell, column, hover, i, j, len, len1, x, y;
        // clear the canvas
        this.context.clearRect(0, 0, canvas.width, canvas.height);
        // set draw and fill styles
        this.context.strokeStyle = "#000000";
        this.context.fillStyle = "#ff0000";
        this.context.lineWidth = "2";
        this.context.beginPath();
//console.log moduleName, "tile size: #{cellSize}"
        for (x = i = 0, len = grid.length; i < len; x = ++i) {
          column = grid[x];
          for (y = j = 0, len1 = column.length; j < len1; y = ++j) {
            cell = column[y];
            //console.log moduleName, "drawing cell x:#{x}, y:#{y}"
            // add to draw queue the bounding box of the cell
            this.context.rect(x * this.cellSize, y * this.cellSize, this.cellSize, this.cellSize);
            if (cell) { // if cell is alive
              this.context.fillRect(x * this.cellSize, y * this.cellSize, this.cellSize, this.cellSize);
            }
          }
        }
        //draw the hoverOverCell
        hover = this.hoverOverCell;
        if (hover && gridTools.isWithinGrid(grid, hover.x, hover.y)) {
          if (grid[hover.x][hover.y]) {
            this.context.fillStyle = "#FFE0E0";
          } else {
            this.context.fillStyle = "#D10000";
          }
          this.context.fillRect(hover.x * this.cellSize, hover.y * this.cellSize, this.cellSize, this.cellSize);
        }
        //stroke the prepared rectangles on the canvas.
        return this.context.stroke();
      }
    };
    //#INITIALIZATION CODE

    // get the 2d drawing context from the canvas.
    ctx = jqCanvas[0].getContext("2d");
    visualizer.context = ctx;
    // eventually we want to have it scrollable, but for now just squeeze the grid onto the screen
    gridRatio = grid.front.length / grid.front[0].length;
    canvasRatio = jqCanvas[0].width / jqCanvas[0].height;
    if (canvasRatio > gridRatio) { // we want to scale the grid height to match the canvas.height
      //console.log moduleName, "canvas relative width is greater than grid relative width"
      cellSize = jqCanvas[0].height / grid.front[0].length;
    } else {
      //console.log moduleName, "canvas relative width is smaller than grid relative width"
      cellSize = jqCanvas[0].width / grid.front.length;
    }
    console.log(cellSize, jqCanvas[0].width, jqCanvas[0].height);
    visualizer.cellSize = cellSize;
    return visualizer;
  });

}).call(this);
